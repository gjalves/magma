// Code generated by protoc-gen-go. DO NOT EDIT.
// source: indexers.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// IndexerInfo provides info about a state indexer.
type IndexerInfo struct {
	// indexer_id is the indexer's ID.
	IndexerId string `protobuf:"bytes,1,opt,name=indexer_id,json=indexerId,proto3" json:"indexer_id,omitempty"`
	// actual_version is the indexer's current version.
	ActualVersion uint32 `protobuf:"varint,2,opt,name=actual_version,json=actualVersion,proto3" json:"actual_version,omitempty"`
	// desired_version is the version to which the indexer will be reindexed.
	DesiredVersion       uint32   `protobuf:"varint,3,opt,name=desired_version,json=desiredVersion,proto3" json:"desired_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexerInfo) Reset()         { *m = IndexerInfo{} }
func (m *IndexerInfo) String() string { return proto.CompactTextString(m) }
func (*IndexerInfo) ProtoMessage()    {}
func (*IndexerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2fc9bb9c1bd5a40, []int{0}
}

func (m *IndexerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IndexerInfo.Unmarshal(m, b)
}
func (m *IndexerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IndexerInfo.Marshal(b, m, deterministic)
}
func (m *IndexerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexerInfo.Merge(m, src)
}
func (m *IndexerInfo) XXX_Size() int {
	return xxx_messageInfo_IndexerInfo.Size(m)
}
func (m *IndexerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexerInfo proto.InternalMessageInfo

func (m *IndexerInfo) GetIndexerId() string {
	if m != nil {
		return m.IndexerId
	}
	return ""
}

func (m *IndexerInfo) GetActualVersion() uint32 {
	if m != nil {
		return m.ActualVersion
	}
	return 0
}

func (m *IndexerInfo) GetDesiredVersion() uint32 {
	if m != nil {
		return m.DesiredVersion
	}
	return 0
}

type GetIndexersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetIndexersRequest) Reset()         { *m = GetIndexersRequest{} }
func (m *GetIndexersRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexersRequest) ProtoMessage()    {}
func (*GetIndexersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2fc9bb9c1bd5a40, []int{1}
}

func (m *GetIndexersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetIndexersRequest.Unmarshal(m, b)
}
func (m *GetIndexersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetIndexersRequest.Marshal(b, m, deterministic)
}
func (m *GetIndexersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexersRequest.Merge(m, src)
}
func (m *GetIndexersRequest) XXX_Size() int {
	return xxx_messageInfo_GetIndexersRequest.Size(m)
}
func (m *GetIndexersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexersRequest proto.InternalMessageInfo

type GetIndexersResponse struct {
	// indexers_by_id contains all tracked indexers, keyed by their ID.
	IndexersById         map[string]*IndexerInfo `protobuf:"bytes,1,rep,name=indexers_by_id,json=indexersById,proto3" json:"indexers_by_id,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GetIndexersResponse) Reset()         { *m = GetIndexersResponse{} }
func (m *GetIndexersResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexersResponse) ProtoMessage()    {}
func (*GetIndexersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2fc9bb9c1bd5a40, []int{2}
}

func (m *GetIndexersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetIndexersResponse.Unmarshal(m, b)
}
func (m *GetIndexersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetIndexersResponse.Marshal(b, m, deterministic)
}
func (m *GetIndexersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexersResponse.Merge(m, src)
}
func (m *GetIndexersResponse) XXX_Size() int {
	return xxx_messageInfo_GetIndexersResponse.Size(m)
}
func (m *GetIndexersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexersResponse proto.InternalMessageInfo

func (m *GetIndexersResponse) GetIndexersById() map[string]*IndexerInfo {
	if m != nil {
		return m.IndexersById
	}
	return nil
}

type StartReindexRequest struct {
	// indexer_id is the ID of the indexer to reindex.
	// If indexer_id is empty, will reindex all necessary indexers.
	IndexerId string `protobuf:"bytes,1,opt,name=indexer_id,json=indexerId,proto3" json:"indexer_id,omitempty"`
	// force the reindex to occur.
	// By default, start reindex will fail if automatic reindexing is enabled.
	// Set force=true to overrule this default.
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartReindexRequest) Reset()         { *m = StartReindexRequest{} }
func (m *StartReindexRequest) String() string { return proto.CompactTextString(m) }
func (*StartReindexRequest) ProtoMessage()    {}
func (*StartReindexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2fc9bb9c1bd5a40, []int{3}
}

func (m *StartReindexRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReindexRequest.Unmarshal(m, b)
}
func (m *StartReindexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReindexRequest.Marshal(b, m, deterministic)
}
func (m *StartReindexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReindexRequest.Merge(m, src)
}
func (m *StartReindexRequest) XXX_Size() int {
	return xxx_messageInfo_StartReindexRequest.Size(m)
}
func (m *StartReindexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReindexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartReindexRequest proto.InternalMessageInfo

func (m *StartReindexRequest) GetIndexerId() string {
	if m != nil {
		return m.IndexerId
	}
	return ""
}

func (m *StartReindexRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type StartReindexResponse struct {
	// update contains a human-readable update on reindex progress
	Update               string   `protobuf:"bytes,1,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartReindexResponse) Reset()         { *m = StartReindexResponse{} }
func (m *StartReindexResponse) String() string { return proto.CompactTextString(m) }
func (*StartReindexResponse) ProtoMessage()    {}
func (*StartReindexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2fc9bb9c1bd5a40, []int{4}
}

func (m *StartReindexResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartReindexResponse.Unmarshal(m, b)
}
func (m *StartReindexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartReindexResponse.Marshal(b, m, deterministic)
}
func (m *StartReindexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReindexResponse.Merge(m, src)
}
func (m *StartReindexResponse) XXX_Size() int {
	return xxx_messageInfo_StartReindexResponse.Size(m)
}
func (m *StartReindexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReindexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartReindexResponse proto.InternalMessageInfo

func (m *StartReindexResponse) GetUpdate() string {
	if m != nil {
		return m.Update
	}
	return ""
}

func init() {
	proto.RegisterType((*IndexerInfo)(nil), "magma.orc8r.state.indexer.IndexerInfo")
	proto.RegisterType((*GetIndexersRequest)(nil), "magma.orc8r.state.indexer.GetIndexersRequest")
	proto.RegisterType((*GetIndexersResponse)(nil), "magma.orc8r.state.indexer.GetIndexersResponse")
	proto.RegisterMapType((map[string]*IndexerInfo)(nil), "magma.orc8r.state.indexer.GetIndexersResponse.IndexersByIdEntry")
	proto.RegisterType((*StartReindexRequest)(nil), "magma.orc8r.state.indexer.StartReindexRequest")
	proto.RegisterType((*StartReindexResponse)(nil), "magma.orc8r.state.indexer.StartReindexResponse")
}

func init() { proto.RegisterFile("indexers.proto", fileDescriptor_e2fc9bb9c1bd5a40) }

var fileDescriptor_e2fc9bb9c1bd5a40 = []byte{
	// 358 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xc1, 0x4b, 0x32, 0x41,
	0x18, 0xc6, 0xbf, 0x55, 0xf4, 0xd3, 0x77, 0xd5, 0xef, 0x6b, 0x94, 0x30, 0x21, 0x90, 0x85, 0xca,
	0x4b, 0x53, 0xd8, 0x45, 0xa2, 0x43, 0x08, 0x11, 0xdb, 0x71, 0x83, 0x0e, 0x5d, 0x64, 0x74, 0x5e,
	0x65, 0x49, 0x77, 0x6c, 0x66, 0x56, 0x5a, 0xe8, 0xef, 0xed, 0xd8, 0xdf, 0x10, 0xed, 0x8c, 0xb5,
	0x92, 0x99, 0x9d, 0x76, 0xe6, 0xd9, 0x67, 0x9f, 0x79, 0xde, 0xdf, 0x32, 0x50, 0x0b, 0x23, 0x8e,
	0x4f, 0x28, 0x15, 0x9d, 0x4b, 0xa1, 0x05, 0xd9, 0x9b, 0xb1, 0xc9, 0x8c, 0x51, 0x21, 0x47, 0x3d,
	0x49, 0x95, 0x66, 0x1a, 0xa9, 0x75, 0x78, 0xcf, 0xe0, 0xfa, 0x66, 0xe9, 0x47, 0x63, 0x41, 0xf6,
	0x01, 0xec, 0x9b, 0x41, 0xc8, 0x9b, 0x4e, 0xdb, 0xe9, 0x94, 0x83, 0xb2, 0x55, 0x7c, 0x4e, 0x0e,
	0xa0, 0xc6, 0x46, 0x3a, 0x66, 0xd3, 0xc1, 0x02, 0xa5, 0x0a, 0x45, 0xd4, 0xcc, 0xb5, 0x9d, 0x4e,
	0x35, 0xa8, 0x1a, 0xf5, 0xce, 0x88, 0xe4, 0x08, 0xfe, 0x71, 0x54, 0xa1, 0x44, 0xfe, 0xe1, 0xcb,
	0xa7, 0xbe, 0x9a, 0x95, 0xad, 0xd1, 0x6b, 0x00, 0xb9, 0x46, 0x6d, 0x0b, 0xa8, 0x00, 0x1f, 0x63,
	0x54, 0xda, 0x7b, 0x71, 0xa0, 0xbe, 0x22, 0xab, 0xb9, 0x88, 0x14, 0x92, 0xf1, 0xe7, 0x60, 0x83,
	0x61, 0x62, 0x0a, 0xe6, 0x3b, 0x6e, 0xf7, 0x92, 0x7e, 0x3b, 0x1f, 0x5d, 0x93, 0x43, 0x97, 0x42,
	0x3f, 0xf1, 0xf9, 0x55, 0xa4, 0x65, 0x12, 0x54, 0xc2, 0x8c, 0xd4, 0x9a, 0xc0, 0xce, 0x17, 0x0b,
	0xf9, 0x0f, 0xf9, 0x07, 0x4c, 0x2c, 0x92, 0xf7, 0x25, 0xb9, 0x80, 0xc2, 0x82, 0x4d, 0x63, 0x4c,
	0x19, 0xb8, 0xdd, 0xc3, 0x0d, 0x2d, 0x32, 0x88, 0x03, 0xf3, 0xd1, 0x79, 0xae, 0xe7, 0x78, 0x37,
	0x50, 0xbf, 0xd5, 0x4c, 0xea, 0x00, 0x53, 0xa3, 0x9d, 0xff, 0xa7, 0x9f, 0xd0, 0x80, 0xc2, 0x58,
	0xc8, 0x91, 0x39, 0xb7, 0x14, 0x98, 0x8d, 0x47, 0xa1, 0xb1, 0x9a, 0x65, 0xa1, 0xed, 0x42, 0x31,
	0x9e, 0x73, 0xa6, 0xd1, 0x06, 0xd9, 0x5d, 0xf7, 0xd5, 0x81, 0xbf, 0xb6, 0x16, 0x89, 0xc0, 0xcd,
	0x70, 0x22, 0xc7, 0xdb, 0xf2, 0x4c, 0xeb, 0xb6, 0xe8, 0xef, 0xf0, 0x7b, 0x7f, 0x88, 0x82, 0x4a,
	0xb6, 0x2b, 0xd9, 0x94, 0xb0, 0x06, 0x50, 0xeb, 0x64, 0x6b, 0xff, 0xf2, 0xc8, 0x53, 0xa7, 0x5f,
	0xba, 0x2f, 0xa6, 0xb7, 0x41, 0x0d, 0xcd, 0xf3, 0xec, 0x2d, 0x00, 0x00, 0xff, 0xff, 0x6f, 0x10,
	0xec, 0x6f, 0x27, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// IndexerClient is the client API for Indexer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IndexerClient interface {
	// GetIndexers returns indexer info for all tracked indexers.
	GetIndexers(ctx context.Context, in *GetIndexersRequest, opts ...grpc.CallOption) (*GetIndexersResponse, error)
	// StartReindex kicks off any required reindex jobs for some or all indexers.
	// Blocks till reindex job returns, streaming loggable updates.
	StartReindex(ctx context.Context, in *StartReindexRequest, opts ...grpc.CallOption) (Indexer_StartReindexClient, error)
}

type indexerClient struct {
	cc grpc.ClientConnInterface
}

func NewIndexerClient(cc grpc.ClientConnInterface) IndexerClient {
	return &indexerClient{cc}
}

func (c *indexerClient) GetIndexers(ctx context.Context, in *GetIndexersRequest, opts ...grpc.CallOption) (*GetIndexersResponse, error) {
	out := new(GetIndexersResponse)
	err := c.cc.Invoke(ctx, "/magma.orc8r.state.indexer.Indexer/GetIndexers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexerClient) StartReindex(ctx context.Context, in *StartReindexRequest, opts ...grpc.CallOption) (Indexer_StartReindexClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Indexer_serviceDesc.Streams[0], "/magma.orc8r.state.indexer.Indexer/StartReindex", opts...)
	if err != nil {
		return nil, err
	}
	x := &indexerStartReindexClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Indexer_StartReindexClient interface {
	Recv() (*StartReindexResponse, error)
	grpc.ClientStream
}

type indexerStartReindexClient struct {
	grpc.ClientStream
}

func (x *indexerStartReindexClient) Recv() (*StartReindexResponse, error) {
	m := new(StartReindexResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IndexerServer is the server API for Indexer service.
type IndexerServer interface {
	// GetIndexers returns indexer info for all tracked indexers.
	GetIndexers(context.Context, *GetIndexersRequest) (*GetIndexersResponse, error)
	// StartReindex kicks off any required reindex jobs for some or all indexers.
	// Blocks till reindex job returns, streaming loggable updates.
	StartReindex(*StartReindexRequest, Indexer_StartReindexServer) error
}

// UnimplementedIndexerServer can be embedded to have forward compatible implementations.
type UnimplementedIndexerServer struct {
}

func (*UnimplementedIndexerServer) GetIndexers(ctx context.Context, req *GetIndexersRequest) (*GetIndexersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexers not implemented")
}
func (*UnimplementedIndexerServer) StartReindex(req *StartReindexRequest, srv Indexer_StartReindexServer) error {
	return status.Errorf(codes.Unimplemented, "method StartReindex not implemented")
}

func RegisterIndexerServer(s *grpc.Server, srv IndexerServer) {
	s.RegisterService(&_Indexer_serviceDesc, srv)
}

func _Indexer_GetIndexers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexerServer).GetIndexers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.state.indexer.Indexer/GetIndexers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexerServer).GetIndexers(ctx, req.(*GetIndexersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Indexer_StartReindex_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartReindexRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IndexerServer).StartReindex(m, &indexerStartReindexServer{stream})
}

type Indexer_StartReindexServer interface {
	Send(*StartReindexResponse) error
	grpc.ServerStream
}

type indexerStartReindexServer struct {
	grpc.ServerStream
}

func (x *indexerStartReindexServer) Send(m *StartReindexResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Indexer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.state.indexer.Indexer",
	HandlerType: (*IndexerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIndexers",
			Handler:    _Indexer_GetIndexers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartReindex",
			Handler:       _Indexer_StartReindex_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "indexers.proto",
}
